WorldState.MakeFact("item", "wallet");
WorldState.MakeFact("item", "apple");
WorldState.MakeFact("edible", "apple");

(:domain test

	(:method (entry_point)

		( branch_first
			(and	(item ?x) // synchronization point for backtracking. ONLY WHEN VARIABLES ARE BOUND
					(not (loggable ?x)) // no backtracking aqui. solo tiene sentido para probar nuevas alternativas. solo cuando hacemos un nuevo binding
					(edible ?x) // no backtracking.
			)
			(	(eat ?x)
			)
		)
	)

	(:method (eat ?inp_x) // this must be bound because of "inp". we check that it is binded

		( branch_first
			(and	(tasty ?inp_x)
			)
			(	(!log ?inp_x)
			)
		)
	)
)




WorldState.MakeFact("item", "wallet");
WorldState.MakeFact("item", "apple");
WorldState.MakeFact("edible", "apple");


(:domain test

	(:method (entry_point)

		( branch_first
			(and	(item ?x)
					(and (loggable ?x ?y))
					(edible ?y)
			)
			(	(!log ?x)
			)
		)
	)
)

(:domain test

	

		( branch_first
			(and	(item ?x)
					(or (loggable ?y)
						(readable ?z) // we need to validate these cases.
					)
					(not (nice ?x ?any_d))
			)
			(	(!log ?y) // variable may not be bound but we are trying to use it!
			)
		)
	)
)

// primitive tasks and call terms need variables to be bound.
// AND: ALWAYS returns ALL cases bound.
// OR: ONLY returns ONE case bound.
// NOT: MAY or MAY NOT return something bound.

// keywords: inp, out, io, any.
// out, io: for axioms.
// any: for preconditions. E.g. any_result. Any is bound but not used.

// macros for call terms and validation in runtime. in the validation we check that the variable must be bound
// same for tasks. macro and inside first we check that the variable is bound and then call the task

// validation in parse time. check that variables used in tasks and call terms are bound
